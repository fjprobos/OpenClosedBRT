{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 def agregarMicrozonas(self, n, macroZ):\
        '''\
        A pesar de que probamos la idea de ir generando un ancho efectivo, para cada microzona, buscando mantener el mismo ancho para todas las microzona,\
        se llego a la conclusion que hacer eso distorciona mucho los resultados ya que se ve alterada la demanda.\
        Es por esto que se optara por mantener los anchos fijos, y angostar el espaciamiento en los lugares mas estrechos como el CBD o CO.\
        :param n: numero de lineas en la red\
        :param macroZ: conjunto de macrozonas de la Red(Ojo, es la propia de la red y no ciudad) Sobre ella se asignan las microzonas.\
        :return: No tiene return, ya que las microzonas se agregan a las macrozonas.\
        '''\
        #Primero se busca la proporcion de ancho del CBD y CP\
        beta = macroZ['CP'].ancho + macroZ['CBD'].ancho + macroZ['CO'].ancho\
        propCBD = macroZ['CBD'].ancho/beta\
        propCP = macroZ['CP'].ancho/beta\
\
        #Ahora vemos el numero de microzonas a asignar a cada macrozona. Notar que el orden da la prioridad de agregar microzonas.\
\
        nCBD = max(int(round(propCBD*(n-3))), 1)#Aca ocurre muchas veces que el centro es muy pequeno por lo que no caben lineas. en ese caso se pone una por default.\
        n0 = max(int(round(propCP*(n-3))), 1)\
        nf = max(n-n0-nCBD, 1)\
\
        assert nf >= 0, 'Error de asignacion de microzonas'\
\
        #Agregamos las microzonas a sus respectivas macrozonas\
        #Hay que hacer notar que las microzonas perifericas ocupan el ancho de sus macrozonas de corredor respectivas.\
\
        #Partimos por el poniente\
        for i in range(n0):\
            mn = microZona(self.lambdap, macroZ['CP'].ancho/float(n0), self.alpha1, 'PN', i, i)\
            m = microZona(self.lambdac, macroZ['CP'].ancho/float(n0), self.R, 'CP', i, i)\
            ms = microZona(self.lambdap, macroZ['CP'].ancho/float(n0), self.alpha2, 'PS', i, i)\
            macroZ['PN'].microZonas.append(mn)\
            macroZ['CP'].microZonas.append(m)\
            macroZ['PS'].microZonas.append(ms)\
            macroZ['PN'].nMicroZonas += 1\
            macroZ['CP'].nMicroZonas += 1\
            macroZ['PS'].nMicroZonas += 1\
\
        #Las de CBD\
        for i in range(nCBD):\
            mn = microZona(self.lambdap, macroZ['CBD'].ancho/float(nCBD), self.alpha1, 'PN', i+n0, i+n0)\
            m = microZona(self.lambdaCBD, macroZ['CBD'].ancho/float(nCBD), self.R, 'CBD', i, i+n0)\
            ms = microZona(self.lambdap, macroZ['CBD'].ancho/float(nCBD), self.alpha2, 'PS', i+n0, i+n0)\
            macroZ['PN'].microZonas.append(mn)\
            macroZ['CBD'].microZonas.append(m)\
            macroZ['PS'].microZonas.append(ms)\
            macroZ['PN'].nMicroZonas += 1\
            macroZ['CBD'].nMicroZonas += 1\
            macroZ['PS'].nMicroZonas += 1\
\
        #Y por ultimo las microzonas de CO\
        for i in range(nf):\
            mn = microZona(self.lambdap, macroZ['CO'].ancho/float(nf), self.alpha1, 'PN', i+n0+nCBD, i+n0+nCBD)\
            m = microZona(self.lambdac, macroZ['CO'].ancho/float(nf), self.R, 'CO', i, i+n0+nCBD)\
            ms = microZona(self.lambdap, macroZ['CO'].ancho/float(nf), self.alpha2, 'PS', i+n0+nCBD, i+n0+nCBD)\
            macroZ['PN'].microZonas.append(mn)\
            macroZ['CO'].microZonas.append(m)\
            macroZ['PS'].microZonas.append(ms)\
            macroZ['PN'].nMicroZonas += 1\
            macroZ['CO'].nMicroZonas += 1\
            macroZ['PS'].nMicroZonas += 1}